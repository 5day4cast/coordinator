{{- if .Values.blueGreen.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "coordinator.fullname" . }}-bg-switchover
  labels:
    {{- include "coordinator.labels" . | nindent 4 }}
  annotations:
    argocd.argoproj.io/hook: PreSync
    argocd.argoproj.io/hook-delete-policy: BeforeHookCreation
spec:
  backoffLimit: 0
  activeDeadlineSeconds: 600
  ttlSecondsAfterFinished: 300
  template:
    metadata:
      labels:
        {{- include "coordinator.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: bg-switchover
    spec:
      serviceAccountName: {{ include "coordinator.fullname" . }}-bg-hook
      restartPolicy: Never
      containers:
        - name: switchover
          image: bitnami/kubectl:latest
          command: ["/bin/bash", "-c"]
          args:
            - |
              set -euo pipefail

              NAMESPACE="{{ .Release.Namespace }}"
              SERVICE="{{ include "coordinator.fullname" . }}"
              DEPLOY_PREFIX="{{ include "coordinator.fullname" . }}"
              CONTAINER="{{ .Chart.Name }}"
              NEW_IMAGE="{{ .Values.image.repository }}:{{ .Values.image.tag }}"

              echo "=== Blue/Green PreSync Switchover ==="
              echo "Namespace: $NAMESPACE"
              echo "Service: $SERVICE"
              echo "New image: $NEW_IMAGE"

              # Get current active slot from Service selector
              ACTIVE=$(kubectl -n "$NAMESPACE" get svc "$SERVICE" \
                -o jsonpath='{.spec.selector.app\.kubernetes\.io/slot}' 2>/dev/null || echo "")

              if [[ -z "$ACTIVE" ]]; then
                echo "No slot selector found on Service. First deploy - initializing."
                # First deploy: scale up blue, set Service selector
                echo "Scaling up ${DEPLOY_PREFIX}-blue..."
                kubectl -n "$NAMESPACE" scale deployment "${DEPLOY_PREFIX}-blue" --replicas=1 || true
                echo "Waiting for ${DEPLOY_PREFIX}-blue to be ready..."
                kubectl -n "$NAMESPACE" rollout status deployment "${DEPLOY_PREFIX}-blue" --timeout=300s || true
                echo "Patching Service selector to blue..."
                kubectl -n "$NAMESPACE" patch svc "$SERVICE" --type=json \
                  -p '[{"op": "add", "path": "/spec/selector/app.kubernetes.io~1slot", "value": "blue"}]' || true
                echo "Scaling down ${DEPLOY_PREFIX}-green..."
                kubectl -n "$NAMESPACE" scale deployment "${DEPLOY_PREFIX}-green" --replicas=0 || true
                echo "First deploy initialization complete."
                exit 0
              fi

              # Determine standby
              if [[ "$ACTIVE" == "blue" ]]; then
                STANDBY="green"
              else
                STANDBY="blue"
              fi

              ACTIVE_DEPLOY="${DEPLOY_PREFIX}-${ACTIVE}"
              STANDBY_DEPLOY="${DEPLOY_PREFIX}-${STANDBY}"

              echo "Active: $ACTIVE ($ACTIVE_DEPLOY)"
              echo "Standby: $STANDBY ($STANDBY_DEPLOY)"

              # Check if active deployment's current running image matches the new image
              CURRENT_IMAGE=$(kubectl -n "$NAMESPACE" get deployment "$ACTIVE_DEPLOY" \
                -o jsonpath="{.spec.template.spec.containers[?(@.name=='$CONTAINER')].image}" 2>/dev/null || echo "")

              echo "Current active image: $CURRENT_IMAGE"

              if [[ "$CURRENT_IMAGE" == "$NEW_IMAGE" ]]; then
                echo "Active deployment already running $NEW_IMAGE. No switchover needed."
                # Ensure standby is scaled down
                kubectl -n "$NAMESPACE" scale deployment "$STANDBY_DEPLOY" --replicas=0 2>/dev/null || true
                exit 0
              fi

              echo ""
              echo "=== Starting switchover: $ACTIVE -> $STANDBY ==="

              # Step 1: Update standby image
              echo "Step 1/6: Setting $STANDBY_DEPLOY image to $NEW_IMAGE"
              kubectl -n "$NAMESPACE" set image "deployment/$STANDBY_DEPLOY" "$CONTAINER=$NEW_IMAGE"

              # Step 2: Scale down active so Litestream flushes WAL to S3 on SIGTERM.
              # This must happen BEFORE the standby starts, otherwise the standby
              # restores stale data from S3 (the active's latest writes haven't
              # been synced yet).
              echo "Step 2/6: Scaling down $ACTIVE_DEPLOY (Litestream will flush WAL to S3)"
              kubectl -n "$NAMESPACE" scale deployment "$ACTIVE_DEPLOY" --replicas=0

              # Step 3: Wait for active pods to fully terminate so Litestream
              # completes its S3 sync on shutdown.
              echo "Step 3/6: Waiting for $ACTIVE_DEPLOY pods to terminate"
              kubectl -n "$NAMESPACE" wait --for=delete pod \
                -l "app.kubernetes.io/slot=$ACTIVE,app.kubernetes.io/name={{ include "coordinator.name" . }}" \
                --timeout=60s 2>/dev/null || true
              echo "$ACTIVE_DEPLOY terminated, S3 backups should be up to date"

              # Step 4: Scale up standby (triggers Litestream restore from fresh S3 data)
              echo "Step 4/6: Scaling up $STANDBY_DEPLOY (will restore DB from S3)"
              kubectl -n "$NAMESPACE" scale deployment "$STANDBY_DEPLOY" --replicas=1

              # Step 5: Wait for readiness
              echo "Step 5/6: Waiting for $STANDBY_DEPLOY to be ready..."
              if ! kubectl -n "$NAMESPACE" rollout status deployment "$STANDBY_DEPLOY" --timeout=300s; then
                echo "ERROR: Standby deployment failed readiness check"
                echo "Rolling back: scaling down standby, scaling up previous active"
                kubectl -n "$NAMESPACE" scale deployment "$STANDBY_DEPLOY" --replicas=0
                kubectl -n "$NAMESPACE" scale deployment "$ACTIVE_DEPLOY" --replicas=1
                exit 1
              fi

              # Step 6: Flip Service selector (503 window ends)
              echo "Step 6/6: Flipping Service selector to $STANDBY"
              kubectl -n "$NAMESPACE" patch svc "$SERVICE" --type=json \
                -p "[{\"op\": \"replace\", \"path\": \"/spec/selector/app.kubernetes.io~1slot\", \"value\": \"$STANDBY\"}]"

              # Verify
              NEW_ACTIVE=$(kubectl -n "$NAMESPACE" get svc "$SERVICE" \
                -o jsonpath='{.spec.selector.app\.kubernetes\.io/slot}')
              echo "Service now pointing to: $NEW_ACTIVE"

              echo ""
              echo "=== Switchover complete ==="
              echo "Active: $STANDBY ($STANDBY_DEPLOY) running $NEW_IMAGE"
              echo "Standby: $ACTIVE ($ACTIVE_DEPLOY) scaled to 0"
          resources:
            requests:
              memory: 32Mi
              cpu: 10m
            limits:
              memory: 64Mi
{{- end }}

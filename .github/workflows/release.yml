name: Release

on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      version:
        description: "Version to release (e.g., 0.8.3)"
        required: true
        type: string
      dry_run:
        description: "Dry run (build only, no release)"
        required: false
        type: boolean
        default: true

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  prepare-release:
    name: Prepare Release
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      version_name: ${{ steps.get_version.outputs.version_name }}
      dry_run: ${{ steps.get_version.outputs.dry_run }}
    steps:
      - name: Get version from tag or input
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ github.event.inputs.version }}"
            DRY_RUN="${{ github.event.inputs.dry_run }}"
          else
            VERSION=${GITHUB_REF#refs/tags/v}
            DRY_RUN="false"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "version_name=v$VERSION" >> $GITHUB_OUTPUT
          echo "dry_run=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION (dry_run: $DRY_RUN)"

  update-versions:
    name: Update Crate Versions
    runs-on: ubuntu-latest
    needs: prepare-release
    if: needs.prepare-release.outputs.dry_run != 'true'
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable

      - name: Install cargo-edit and update versions
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          echo "Updating all crates to version $VERSION"
          cargo install cargo-edit --locked
          cargo set-version --workspace $VERSION

          echo "Updated versions:"
          grep "^version" Cargo.toml
          grep "^version" crates/*/Cargo.toml

      - name: Commit version updates
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add Cargo.toml Cargo.lock crates/*/Cargo.toml
          git commit -m "chore: bump version to ${{ needs.prepare-release.outputs.version }}" || echo "No changes to commit"
          git push origin HEAD:master || echo "No changes to push"

  build-release:
    name: Build Release (${{ matrix.target }})
    runs-on: ${{ matrix.os }}
    needs: prepare-release
    if: always() && needs.prepare-release.result == 'success'
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            artifact_name: coordinator
            asset_name: coordinator-x86_64-linux
          - os: macos-latest
            target: x86_64-apple-darwin
            artifact_name: coordinator
            asset_name: coordinator-x86_64-macos
          - os: macos-latest
            target: aarch64-apple-darwin
            artifact_name: coordinator
            asset_name: coordinator-aarch64-macos

    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true
          sudo apt-get clean || true

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Install dependencies (Linux)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y libssl-dev pkg-config

      - name: Build release binary
        run: |
          cargo build --release --locked --target ${{ matrix.target }} -p coordinator
        env:
          SQLX_OFFLINE: "true"

      - name: Create release package
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          PKG_NAME="${{ matrix.asset_name }}-${VERSION}"

          mkdir -p "${PKG_NAME}/bin"
          mkdir -p "${PKG_NAME}/migrations"

          # Copy binary
          cp target/${{ matrix.target }}/release/${{ matrix.artifact_name }} "${PKG_NAME}/bin/"

          # Copy migrations
          cp -r crates/coordinator/migrations/* "${PKG_NAME}/migrations/"

          # Create README
          cat > "${PKG_NAME}/README.txt" << EOF
          Coordinator v${VERSION}
          =======================

          A DLC competition coordination server.

          Usage:
            ./bin/coordinator --help

          Migrations:
            The migrations/ directory contains database migrations.
            These are applied automatically on startup.

          For more info: https://github.com/5day4cast/coordinator
          EOF

          # Create archive
          if [ "${{ runner.os }}" = "Windows" ]; then
            7z a "${PKG_NAME}.zip" "${PKG_NAME}"
          else
            tar czf "${PKG_NAME}.tar.gz" "${PKG_NAME}"
          fi

          mkdir -p release
          mv ${PKG_NAME}.* release/
          ls -lh release/

      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.target }}
          path: release/*
          retention-days: 7

  build-wasm:
    name: Build WASM Package
    runs-on: ubuntu-latest
    needs: prepare-release
    if: always() && needs.prepare-release.result == 'success'
    steps:
      - uses: actions/checkout@v4

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: wasm32-unknown-unknown

      - name: Install wasm-pack
        run: cargo install wasm-pack

      - name: Build WASM
        run: |
          cd crates/coordinator-wasm
          wasm-pack build --target web --release
        env:
          # Workaround for secp256k1-sys WASM build with clang 16+
          # The wasm-sysroot in secp256k1-sys is missing memmove declaration in string.h
          # Newer clang versions treat implicit function declarations as errors
          CFLAGS_wasm32_unknown_unknown: "-Wno-error=implicit-function-declaration"

      - name: Create WASM package
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          PKG_NAME="coordinator-wasm-${VERSION}"

          mkdir -p "${PKG_NAME}"
          cp -r crates/coordinator-wasm/pkg/* "${PKG_NAME}/"

          tar czf "${PKG_NAME}.tar.gz" "${PKG_NAME}"

          mkdir -p release
          mv "${PKG_NAME}.tar.gz" release/
          ls -lh release/

      - name: Upload WASM artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-wasm
          path: release/*
          retention-days: 7

  create-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [prepare-release, build-release, build-wasm]
    if: needs.prepare-release.outputs.dry_run != 'true'
    permissions:
      contents: write
    steps:
      - uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Display structure of downloaded files
        run: ls -R artifacts

      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          name: Release ${{ needs.prepare-release.outputs.version_name }}
          tag_name: ${{ needs.prepare-release.outputs.version_name }}
          draft: false
          prerelease: false
          generate_release_notes: true
          files: |
            artifacts/**/*.tar.gz
            artifacts/**/*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Build and push Docker images to GHCR
  build-docker-amd64:
    name: Build Docker Image (amd64)
    runs-on: ubuntu-latest
    needs: [prepare-release]
    if: always() && needs.prepare-release.result == 'success'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push x86_64 image
        run: |
          nix build .#docker-coordinator --print-build-logs
          docker load < result
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker tag coordinator:latest ghcr.io/${REPO_LOWER}:${{ needs.prepare-release.outputs.version }}-amd64
          docker tag coordinator:latest ghcr.io/${REPO_LOWER}:latest-amd64

          if [ "${{ needs.prepare-release.outputs.dry_run }}" != "true" ]; then
            docker push ghcr.io/${REPO_LOWER}:${{ needs.prepare-release.outputs.version }}-amd64
            docker push ghcr.io/${REPO_LOWER}:latest-amd64
          fi

  build-docker-arm64:
    name: Build Docker Image (arm64)
    runs-on: ubuntu-24.04-arm
    needs: [prepare-release]
    if: always() && needs.prepare-release.result == 'success'
    permissions:
      contents: read
      packages: write
    steps:
      - uses: actions/checkout@v4

      - name: Free up disk space
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf /usr/local/lib/android
          sudo rm -rf /opt/ghc
          sudo rm -rf /opt/hostedtoolcache/CodeQL
          sudo docker image prune --all --force || true

      - name: Install Nix
        uses: DeterminateSystems/nix-installer-action@main

      - name: Setup Nix cache
        uses: DeterminateSystems/magic-nix-cache-action@main
        with:
          use-gha-cache: false
          use-flakehub: false

      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push ARM64 image
        run: |
          nix build .#docker-coordinator --print-build-logs
          docker load < result
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          docker tag coordinator:latest ghcr.io/${REPO_LOWER}:${{ needs.prepare-release.outputs.version }}-arm64
          docker tag coordinator:latest ghcr.io/${REPO_LOWER}:latest-arm64

          if [ "${{ needs.prepare-release.outputs.dry_run }}" != "true" ]; then
            docker push ghcr.io/${REPO_LOWER}:${{ needs.prepare-release.outputs.version }}-arm64
            docker push ghcr.io/${REPO_LOWER}:latest-arm64
          fi

  create-docker-manifest:
    name: Create Docker Manifest
    runs-on: ubuntu-latest
    needs: [prepare-release, build-docker-amd64, build-docker-arm64]
    if: needs.prepare-release.outputs.dry_run != 'true'
    permissions:
      contents: read
      packages: write
    steps:
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Create and push multi-arch manifest
        run: |
          VERSION="${{ needs.prepare-release.outputs.version }}"
          REPO_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          IMAGE="ghcr.io/${REPO_LOWER}"

          # Create and push multi-arch manifests
          docker manifest create ${IMAGE}:${VERSION} \
            ${IMAGE}:${VERSION}-amd64 \
            ${IMAGE}:${VERSION}-arm64
          docker manifest push ${IMAGE}:${VERSION}

          docker manifest create ${IMAGE}:latest \
            ${IMAGE}:latest-amd64 \
            ${IMAGE}:latest-arm64
          docker manifest push ${IMAGE}:latest

          echo "Pushed multi-arch image: ${IMAGE}:${VERSION}"
